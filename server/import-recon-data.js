#!/usr/bin/env node/** * Import Recon Visualization Data into SQLite Database *  * This script imports the visualization-formatted JSON data into the SQLite database * for use with the web interface. */const fs = require('fs');const path = require('path');const sqlite3 = require('sqlite3').verbose();// Get command line argumentsconst args = process.argv.slice(2);const defaultDataFile = path.join(__dirname, '..', 'results', 'recon_sql_20250910-211053_viz.json');const dataFile = args[0] || defaultDataFile;// Database connectionconst db = new sqlite3.Database(path.join(__dirname, 'data.db'));// Enable foreign keysdb.run('PRAGMA foreign_keys = ON');// Clear existing datafunction clearTables() {    const tables = [        'node_relationships',        'node_headers',        'node_technologies',        'node_vulnerabilities',        'nodes',        'websites'    ];        db.serialize(() => {        // Disable foreign keys temporarily for faster deletion        db.run('PRAGMA foreign_keys = OFF');                tables.forEach(table => {            db.run(`DELETE FROM ${table}`);            console.log(`Cleared table: ${table}`);        });                // Re-enable foreign keys        db.run('PRAGMA foreign_keys = ON');    });}// Insert a website and get its IDfunction insertWebsite(url, name) {    return new Promise((resolve, reject) => {        const stmt = db.prepare('INSERT INTO websites (url, name, created_at) VALUES (?, ?, datetime("now"))');        stmt.run(url, name || url, function(err) {            if (err) {                reject(err);            } else {                console.log(`Inserted website: ${url} with ID ${this.lastID}`);                resolve(this.lastID);            }        });        stmt.finalize();    });}// Insert a node and get its IDfunction insertNode(websiteId, nodeData) {    return new Promise((resolve, reject) => {        const stmt = db.prepare(            'INSERT INTO nodes (website_id, value, type, status, size, created_at) VALUES (?, ?, ?, ?, ?, datetime("now"))'        );        stmt.run(            websiteId,            nodeData.value,            nodeData.type,            nodeData.status || 0,            nodeData.size || 0,            function(err) {                if (err) {                    reject(err);                } else {                    const nodeId = this.lastID;                    console.log(`Inserted node: ${nodeData.value} (${nodeData.type}) with ID ${nodeId}`);                                        // Insert headers, technologies and vulnerabilities                    if (nodeData.headers && nodeData.headers.length > 0) {                        insertHeaders(nodeId, nodeData.headers);                    }                                        if (nodeData.technologies && nodeData.technologies.length > 0) {                        insertTechnologies(nodeId, nodeData.technologies);                    }                                        if (nodeData.vulnerabilities && nodeData.vulnerabilities.length > 0) {                        insertVulnerabilities(nodeId, nodeData.vulnerabilities);                    }                                        resolve(nodeId);                }            }        );        stmt.finalize();    });}// Insert headers for a nodefunction insertHeaders(nodeId, headers) {    const stmt = db.prepare('INSERT INTO node_headers (node_id, header_key, header_value) VALUES (?, ?, ?)');    headers.forEach(header => {        stmt.run(nodeId, header.key, header.value);    });    stmt.finalize();    console.log(`Inserted ${headers.length} headers for node ID ${nodeId}`);}// Insert technologies for a nodefunction insertTechnologies(nodeId, technologies) {    const stmt = db.prepare('INSERT INTO node_technologies (node_id, technology) VALUES (?, ?)');    technologies.forEach(tech => {        stmt.run(nodeId, tech);    });    stmt.finalize();    console.log(`Inserted ${technologies.length} technologies for node ID ${nodeId}`);}// Insert vulnerabilities for a nodefunction insertVulnerabilities(nodeId, vulnerabilities) {    const stmt = db.prepare('INSERT INTO node_vulnerabilities (node_id, vulnerability) VALUES (?, ?)');    vulnerabilities.forEach(vuln => {        stmt.run(nodeId, vuln);    });    stmt.finalize();    console.log(`Inserted ${vulnerabilities.length} vulnerabilities for node ID ${nodeId}`);}// Insert relationship between nodesfunction insertRelationship(sourceId, targetId, type) {    return new Promise((resolve, reject) => {        const stmt = db.prepare('INSERT INTO node_relationships (source_id, target_id, type) VALUES (?, ?, ?)');        stmt.run(sourceId, targetId, type, function(err) {            if (err) {                reject(err);            } else {                console.log(`Inserted relationship: ${sourceId} -> ${targetId} (${type})`);                resolve(this.lastID);            }        });        stmt.finalize();    });}// Main function to insert recon data from fileasync function insertReconData(filePath) {    try {        // Load data from file        console.log(`Loading data from ${filePath}...`);        const data = JSON.parse(fs.readFileSync(filePath, 'utf8'));                if (!data.website || !data.nodes || !data.relationships) {            throw new Error('Invalid data format. Expected website, nodes, and relationships properties.');        }                console.log('Data loaded successfully.');        console.log(`Website: ${data.website.url}`);        console.log(`Total nodes: ${data.nodes.length}`);        console.log(`Total relationships: ${data.relationships.length}`);                // Clear existing data        console.log('\nClearing existing data...');        clearTables();                // Insert website        console.log('\nInserting website...');        const websiteId = await insertWebsite(data.website.url, data.website.name);                // Insert nodes        console.log('\nInserting nodes...');        const nodeIds = {};        for (const node of data.nodes) {            const nodeId = await insertNode(websiteId, node);            nodeIds[node.value] = nodeId;        }                // Insert relationships        console.log('\nInserting relationships...');        for (const rel of data.relationships) {            const sourceId = nodeIds[rel.source];            const targetId = nodeIds[rel.target];                        if (!sourceId || !targetId) {                console.log(`Warning: Could not find node IDs for relationship ${rel.source} -> ${rel.target}`);                continue;            }                        await insertRelationship(sourceId, targetId, rel.type);        }                console.log('\nData import completed successfully!');    } catch (error) {        console.error('Error importing data:', error);    } finally {        // Close the database connection        db.close((err) => {            if (err) {
                console.error('Error closing database:', err.message);
            } else {
                console.log('Database connection closed.');
            }
        });
    }
}

// Run the insertion with the specified or default file
console.log(`Starting import of ${dataFile}`);
insertReconData(dataFile);
